/************************************************************************************************/
//Projet   : Projet TP_2_Labyrinthe
//Fichier  : Module_Pile.c
//Contenu  : Contient les fonction relatif à la création, modification et destruction de pile
//Objectif : Création d'un algorithme de réalisation de labyrinthe
//Création : 20 Octobre 2014
//                                                  Creer par Samuel - Link - Geoffroy-Heroux
//                                                            Francis Masse
//                                                            Christopher Dom
//                                                            Vincent Lynch
/************************************************************************************************/

/*                                       MODIFICATION                                           */
/************************************************************************************************/
//Modification : 23 Octobre 2014 --> Link
//      -- Ajout de assert() pour tester l'allocation de memoire
//      -- Recréation de pile_copier(). Permet la copie de nos pile qu'elles soit plus grande ou plus petite l'une de l'autre
//      -- Modification de pile_ajouter() et pile_enlever().
//      -- Ajout de ifndef
//      -- Ajout de beaucoup de commentaires
/************************************************************************************************/

/*                                          DEFINE                                              */
/************************************************************************************************/

#define MOD_PILE
/************************************************************************************************/

/*                                         INCLUDES                                             */
/************************************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
//#include <string.h>
//#include <memory.h>
/************************************************************************************************/

/*                                        DECLARATION                                           */
/************************************************************************************************/

void pile_initialiser(int* pile[], int* nb_elements);
/*
Cette fonction sert a initialiser une pile et sont nb_elements à NULL.
Parametre : int* pile[]         --> Pointeur sur tableau (qui est notre pile)
int* nb_elements    --> Pointeur sur le nombre d'éléments de la pile
Return : Void
*/
/************************************************************************************************/


void pile_detruire(int pile[], int* nb_elements);
/*
Cette fonction sert a detruire une pile et de remettre son adresse à NULL et le nombre d'éléments à 0.
Parametre : int pile[]         --> Tableau (qui est notre pile)
int* nb_elements    --> Pointeur sur le nombre d'éléments de la pile
Return : Void
*/
/************************************************************************************************/

void pile_initialiser_version_utile(int* pile[], int* nb_elements, int grandeur_pile);
/*
Cette fonction sert a initialiser une pile à un grandeur prédéterminée.
Parametre : int* pile[]         --> Pointeur sur tableau (qui est notre pile)
int* nb_elements    --> Pointeur sur le nombre d'éléments de la pile
int grandeur_pile    --> grandeur désirée de la pile (i.e. valeur qu'aura le NB d'élément)
Return : Void
*/
/************************************************************************************************/

void pile_copier(int* pile_destination[], int *nb_elements_destination, int pile_source[], int nb_elements_source);
/*
Cette fonction sert a copier une pile dans un autre.

Parametre : int* pile_destination[]      --> Pointeur vers notre pile de destination
int *nb_elements_destination     --> pointeur vers le nombre d'éléments de la pile de destination
int pile_source                --> tableau (pile) à copier dans la nouvelle pile
int nb_element_source           --> Nombre d'éléments de la pile de source
Return : Void
*/
/************************************************************************************************/

void pile_ajouter(int* pile[], int* nb_elements, int entier);
/*
Cette fonction sert a ajouter un element à une pile.
Parametre : int* pile[]         --> Pointeur sur tableau (qui est notre pile)
int* nb_elements    --> Pointeur sur le nombre d'éléments de la pile
int entier          --> L'entier à ajouter sur le dessus de la pile
Return : Void
*/
/************************************************************************************************/

int pile_enlever(int* pile[], int nb_elements);
/*
Cette fonction sert a enlever le dernier élément d'une pile.
Parametre : int* pile[]         --> Pointeur sur tableau (qui est notre pile)
int* nb_elements    --> Pointeur sur le nombre d'éléments de la pile
Return : l'entier qui à été enlever
*/

/************************************************************************************************/

void pile_afficher(int *pile[], int nb_elements);
/*
Cette fonction sert a afficher tous les éléments d'une pile.
Parametre : int* pile[]         --> Pointeur sur tableau (qui est notre pile)
int nb_elements     --> Nombre d'éléments de la pile
Return : Void
*/

/************************************************************************************************/

void pile_tronquer(int * pile[], int* nb_elements, int indice);
/*

Parametre :
Return :
*/

/************************************************************************************************/

int pile_est_present(int pile[], int nb_elements, int entier);
/*

Parametre :
Return :
*/


/************************************************************************************************/

void pile_concatener(int* pile_destination[], int* nb_elements_destination, int pile_source[], int nb_elements_source);
/*

Parametre :
Return :
*/

/************************************************************************************************/


int main()
{
	int** pile = NULL; //créé un pointeur pointant vers l'adresse de début d'un tableau de integers
	int nb_elements_pile1 = 4; //initilialise le NB d'élément des piles à 0
	int nb_elements_pile2 = 4;

	int* pile1 = NULL; //initilialise le NB d'élément des piles à 0
	int* pile2 = NULL;
	pile = &pile1;

	printf("Debut du program\n");

	pile_initialiser_version_utile(pile, &nb_elements_pile1, 4);
	*(*pile) = 3;
	*(*pile + 1) = 5;
	*(*pile + 2) = 7;
	*(*pile + 3) = 11;
	printf("Initialisation de la pile\n");

	printf("valeur de pile: %d (adresse de l'adresse de pile1[0])\n", pile);
	printf("valeur de *pile: %d (adresse de pile1[0])\n", *pile);

	printf("valeur de **pile: %d (valeur contenue dans pile1[0])\n", **pile);
	printf("valeur de **pile: %d (valeur contenue dans pile1[1])\n", *(*pile + 1));
	printf("valeur de **pile: %d (valeur contenue dans pile1[2])\n", *(*pile + 2));
	printf("valeur de **pile: %d (valeur contenue dans pile1[3])\n", *(*pile + 3));

	printf("sizeof pile: %d (sizeof adresse de l'adresse de pile1[0])\n", sizeof(pile));
	printf("sizeof de *pile: %d (sizeof adresse de pile1[0])\n", sizeof(*pile));
	printf("sizeof de **pile: %d (sizeof valeur contenue dans pile1[0])\n\n\n", sizeof(*pile[0]));

	system("pause");

	/////////////////////////////////////////////////////////////////////////////////////////

	pile = &pile2;
	pile_initialiser_version_utile(pile, &nb_elements_pile2, 4);
	pile_copier(pile, &nb_elements_pile2, pile1, nb_elements_pile1);

	printf("Copie de la pile 1 dasn la pile 2\n");

	printf("valeur de pile: %d (adresse de l'adresse de pile2[0])\n", pile);
	printf("valeur de *pile: %d (adresse de pile2[0])\n", *pile);

	printf("valeur de **pile: %d (valeur contenue dans pile2[0])\n", **pile);
	printf("valeur de **pile: %d (valeur contenue dans pile2[1])\n", *(*pile + 1));
	printf("valeur de **pile: %d (valeur contenue dans pile2[2])\n", *(*pile + 2));
	printf("valeur de **pile: %d (valeur contenue dans pile2[3])\n", *(*pile + 3));

	printf("sizeof pile: %d (sizeof adresse de l'adresse de pile2[0])\n", sizeof(pile));
	printf("sizeof de *pile: %d (sizeof adresse de pile2[0])\n", sizeof(*pile));
	printf("sizeof de **pile: %d (sizeof valeur contenue dans pile2[0])\n\n\n", sizeof(*pile[0]));

	system("pause");

	/////////////////////////////////////////////////////////////////////////////////////////

	pile = &pile1;
	pile_ajouter(pile, &nb_elements_pile1, 43);

	printf("ajout a la pile\n");

	printf("valeur de pile: %d (adresse de l'adresse de pile1[0])\n", pile);
	printf("valeur de *pile: %d (adresse de pile1[0])\n", *pile);

	printf("valeur de **pile: %d (valeur contenue dans pile1[0])\n", **pile);
	printf("valeur de **pile: %d (valeur contenue dans pile1[1])\n", *(*pile + 1));
	printf("valeur de **pile: %d (valeur contenue dans pile1[2])\n", *(*pile + 2));
	printf("valeur de **pile: %d (valeur contenue dans pile1[3])\n", *(*pile + 3));
	printf("valeur de **pile: %d (valeur contenue dans pile1[4])\n", *(*pile + 4));

	printf("sizeof pile: %d (sizeof adresse de l'adresse de pile1[0])\n", sizeof(pile));
	printf("sizeof de *pile: %d (sizeof adresse de pile1[0])\n", sizeof(*pile));
	printf("sizeof de **pile: %d (sizeof valeur contenue dans pile1[0])\n\n\n", sizeof(*pile[0]));

	system("pause");

	/////////////////////////////////////////////////////////////////////////////////////////

	printf("\n\n\nafficher la pile\n");
	pile_afficher(pile, nb_elements_pile1);

	system("pause");

	/////////////////////////////////////////////////////////////////////////////////////////
	
	pile_concatener(pile, &nb_elements_pile1, pile2, nb_elements_pile2);

	printf("\n\concatener pile2 à pile1 vers pile1\n");

	printf("valeur de pile: %d (adresse de l'adresse de pile1[0])\n", pile);
	printf("valeur de *pile: %d (adresse de pile1[0])\n", *pile);

	printf("valeur de **pile: %d (valeur contenue dans pile1[0])\n", **pile);
	printf("valeur de **pile: %d (valeur contenue dans pile1[1])\n", *(*pile + 1));
	printf("valeur de **pile: %d (valeur contenue dans pile1[2])\n", *(*pile + 2));
	printf("valeur de **pile: %d (valeur contenue dans pile1[3])\n", *(*pile + 3));
	printf("valeur de **pile: %d (valeur contenue dans pile1[4])\n", *(*pile + 4));
	printf("valeur de **pile: %d (valeur contenue dans pile1[5])\n", *(*pile + 5));
	printf("valeur de **pile: %d (valeur contenue dans pile1[6])\n", *(*pile + 6));
	printf("valeur de **pile: %d (valeur contenue dans pile1[7])\n", *(*pile + 7));
	printf("valeur de **pile: %d (valeur contenue dans pile1[8])\n", *(*pile + 8));
	printf("valeur de **pile: %d (valeur contenue dans pile1[9])\n", *(*pile + 9));

	printf("sizeof pile: %d (sizeof adresse de l'adresse de pile1[0])\n", sizeof(pile));
	printf("sizeof de *pile: %d (sizeof adresse de pile1[0])\n", sizeof(*pile));
	printf("sizeof de **pile: %d (sizeof valeur contenue dans pile1[0])\n\n\n", sizeof(*pile[0]));

	system("pause");


	system("pause");

	/////////////////////////////////////////////////////////////////////////////////////////
	printf("\n\nenlever %d a la pile\n", pile_enlever(pile, &nb_elements_pile1));

	printf("valeur de pile: %d (adresse de l'adresse de pile1[0])\n", pile);
	printf("valeur de *pile: %d (adresse de pile1[0])\n", *pile);

	printf("valeur de **pile: %d (valeur contenue dans pile1[0])\n", **pile);
	printf("valeur de **pile: %d (valeur contenue dans pile1[1])\n", *(*pile + 1));
	printf("valeur de **pile: %d (valeur contenue dans pile1[2])\n", *(*pile + 2));
	printf("valeur de **pile: %d (valeur contenue dans pile1[3])\n", *(*pile + 3));
	printf("valeur de **pile: %d (valeur contenue dans pile1[4])\n", *(*pile + 4));

	printf("sizeof pile: %d (sizeof adresse de l'adresse de pile1[0])\n", sizeof(pile));
	printf("sizeof de *pile: %d (sizeof adresse de pile1[0])\n", sizeof(*pile));
	printf("sizeof de **pile: %d (sizeof valeur contenue dans pile1[0])\n\n\n", sizeof(*pile[0]));
	
	system("pause");

	/////////////////////////////////////////////////////////////////////////////////////////

	pile_tronquer(pile, &nb_elements_pile1, 3);

	printf("\n\ntronquer la pile\n");

	printf("valeur de pile: %d (adresse de l'adresse de pile1[0])\n", pile);
	printf("valeur de *pile: %d (adresse de pile1[0])\n", *pile);

	printf("valeur de **pile: %d (valeur contenue dans pile1[0])\n", **pile);
	printf("valeur de **pile: %d (valeur contenue dans pile1[1])\n", *(*pile + 1));
	printf("valeur de **pile: %d (valeur contenue dans pile1[2])\n", *(*pile + 2));
	printf("valeur de **pile: %d (valeur contenue dans pile1[3])\n", *(*pile + 3));
	printf("valeur de **pile: %d (valeur contenue dans pile1[4])\n", *(*pile + 4));

	printf("sizeof pile: %d (sizeof adresse de l'adresse de pile1[0])\n", sizeof(pile));
	printf("sizeof de *pile: %d (sizeof adresse de pile1[0])\n", sizeof(*pile));
	printf("sizeof de **pile: %d (sizeof valeur contenue dans pile1[0])\n\n\n", sizeof(*pile[0]));

	system("pause");

	/////////////////////////////////////////////////////////////////////////////////////////

	printf("pile_est_present de %d = %d\n\n\n", 3, pile_est_present(pile1, nb_elements_pile1, 3));
	printf("pile_est_present de %d = %d\n\n\n", 5, pile_est_present(pile1, nb_elements_pile1, 5));
	printf("pile_est_present de %d = %d\n\n\n", 7, pile_est_present(pile1, nb_elements_pile1, 7));
	printf("pile_est_present de %d = %d\n\n\n", 11, pile_est_present(pile1, nb_elements_pile1, 11));
	printf("pile_est_present de %d = %d\n\n\n", -33686019, pile_est_present(pile1, nb_elements_pile1, -33686019));

	system("pause");

	/////////////////////////////////////////////////////////////////////////////////////////

	pile_detruire(pile1, &nb_elements_pile1);

	printf("Destruction de la pile\n");

	printf("valeur de pile: %d (adresse de l'adresse de pile[0])\n", pile);
	printf("valeur de *pile: %d (adresse de pile[0])\n", *pile);
	printf("valeur de **pile: %d (valeur contenue dans pile[0])\n", **pile);

	printf("sizeof pile: %d (sizeof adresse de l'adresse de pile[0])\n", sizeof(pile));
	printf("sizeof de *pile: %d (sizeof adresse de pile[0])\n", sizeof(*pile));
	printf("sizeof de **pile: %d (sizeof valeur contenue dans pile[0])\n\n\n", sizeof(**pile));

	system("pause");

	/////////////////////////////////////////////////////////////////////////////////////////

	
}

//Teste des fonctions


/*                                        DEFINITION                                            */
/************************************************************************************************/
void pile_initialiser(int* pile[], int* nb_elements)
{
	*nb_elements = 0;

	*pile = (int *)calloc(*nb_elements, sizeof(int*)); //créé 0 byte de mémoire ayant l'adresse de pile[0] comme début
	assert(*pile != NULL);

	/* The calloc() function allocates memory for an array of nmemb elements
	of size bytes each and returns a pointer to the allocated memory.
	The memory is set to zero. If nmemb or size is 0, then calloc()
	returns either NULL, or a unique pointer value that can later be
	successfully passed to free().*/// -http://man7.org/linux/man-pages/man3/malloc.3.html
}



void pile_detruire(int pile[], int* nb_elements)
{

	*nb_elements = 0;
	free(pile);
	pile = NULL;
}



void pile_initialiser_version_utile(int* pile[], int* nb_elements, int grandeur_pile)
{

	*nb_elements = grandeur_pile;

	*pile = (int *)calloc(*nb_elements, sizeof(int*));

	/*créé le NB de mémoire pour accueillir grandeur_pile NB de bytes
	assigne l'adresse du début de ce bloc de mémoire à l'adresse de pile[0]*/
	assert(*pile != NULL);
}



void pile_copier(int* pile_destination[], int *nb_elements_destination, int pile_source[], int nb_elements_source)
{

	int d = *nb_elements_destination - 1;
	int i = nb_elements_source - 1;

	for (; (i >= 0) && (d >= 0); i--)
	{
		*(*pile_destination + d) = *(pile_source + i);
		d--;
	}
}



void pile_ajouter(int* pile[], int* nb_elements, int entier)
{

	//Initialisation des variables temporaire
	int nb_ele_temp;
	int* pile_temp = NULL;

	//Allocation de la memoire temporaire
	pile_initialiser_version_utile(&pile_temp, &nb_ele_temp, *nb_elements + 1); //On veut un tableau une case plus grande

	//Verification si le pointeur est en erreur
	assert((pile_temp) != NULL);

	pile_copier(&pile_temp, &nb_ele_temp, *pile, *nb_elements);
	*pile_temp = entier; //assigne l'entier à la position 0 de la nouvelle pile

	free(*pile);               //Libération de la première pile
	*pile = pile_temp;         //assignation de la nouvelle pile
	(*nb_elements)++;
}


int pile_enlever(int* pile[], int* nb_elements)
{
	//sauvegarde l'entier qui sera enlevé
	int entier_enleve = **pile;

	//Initialisation des variables temporaire
	int nb_ele_temp;
	int* pile_temp = NULL;

	//Allocation de la memoire temporaire
	pile_initialiser_version_utile(&pile_temp, &nb_ele_temp, *nb_elements - 1); //On veut un tableau une case plus petite

	//Verification si le pointeur est en erreur
	assert((pile_temp) != NULL);

	pile_copier(&pile_temp, &nb_ele_temp, *pile, *nb_elements);

	free(*pile);               //Libération de la première pile
	*pile = pile_temp;           //assignation de la nouvelle pile
	(*nb_elements)--;

	return entier_enleve;
}


void pile_afficher(int *pile[], int nb_elements)
{
	//Affiche tous les éléments de la pile
	int i;

	for (i = 0; i < nb_elements; i++)
	{
		printf("Deplacement #%d : %d\n", i, *(*pile+i));
	}
}



void pile_tronquer(int * pile[], int* nb_elements, int indice)
{
	//Initialisation des variables temporaire
	int nb_ele_temp;
	int* pile_temp = NULL;

	//Allocation de la memoire temporaire
	pile_initialiser_version_utile(&pile_temp, &nb_ele_temp, indice+1); //On veut un tableau de grosseur indice+1

	//Verification si le pointeur est en erreur
	assert((pile_temp) != NULL);

	pile_copier(&pile_temp, &nb_ele_temp, *pile, *nb_elements);

	free(*pile);               //Libération de la première pile
	*pile = pile_temp;           //assignation de la nouvelle pile
	(*nb_elements) = indice+1;

	//il est important de noter que cette fonction enleve la fin (le dessus) de notre pile, 
	//mais comme le dessus de notre pile est a l'indice 0, elle tronque a partir de l'element 0
	//afin qu'il RESTE (indice+1) element dans la pile
}


int pile_est_present(int pile[], int nb_elements, int entier)
{
	int x = 0;

	for (x = 0; x < nb_elements; x++)
	{
		if (pile[x] == entier)  
		{ 
			return x; 
		}
	}
	return -1;
}


void pile_concatener(int* pile_destination[], int* nb_elements_destination, int pile_source[], int nb_elements_source)
{

	//Initialisation des variables temporaire
	int nb_ele_temp;
	int* pile_temp = NULL;

	//Allocation de la memoire temporaire
	//On veut un tableau qui aura la grandeur des 2 tableaux réunis
	pile_initialiser_version_utile(&pile_temp, &nb_ele_temp, *nb_elements_destination + nb_elements_source); 

	//Verification si le pointeur est en erreur
	assert((pile_temp) != NULL);
	
	//le dernier element (0) de pile_source sera sur le dessus de la nouvelle pile (0)
	pile_copier(&pile_temp, &nb_ele_temp, *pile_destination, *nb_elements_destination);

	pile_temp -= *nb_elements_destination; //some fucked up arithmetic, was on acid.
	pile_copier(&pile_temp, &nb_ele_temp, pile_source, nb_elements_source);
	pile_temp += *nb_elements_destination;
	
	free(pile_source);					  //Libération de la pile source
	free(*pile_destination);			  //Libération de la pile source

	*pile_destination = pile_temp;         //assignation de la nouvelle pile
	*nb_elements_destination = *nb_elements_destination + nb_elements_source;
}

