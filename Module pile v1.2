/************************************************************************************************/
//Projet   : Projet TP_2_Labyrinthe
//Fichier  : Module_Pile.c
//Contenu  : Contient les fonction relatif à la création, modification et destruction de pile
//Objectif : Création d'un algorithme de réalisation de labyrinthe
//Création : 20 Octobre 2014
//                                                  Creer par Samuel - Link - Geoffroy-Heroux
//                                                            Francis Masse
//                                                            Christopher Dom
//                                                            Vincent Lynch
/************************************************************************************************/

/*                                       MODIFICATION                                           */
/************************************************************************************************/
//Modification : 23 Octobre 2014 --> Link
//      -- Ajout de assert() pour tester l'allocation de memoire
//      -- Recréation de pile_copier(). Permet la copie de nos pile qu'elles soit plus grande ou plus petite l'une de l'autre
//      -- Modification de pile_ajouter() et pile_enlever().
//      -- Ajout de ifndef
//      -- Ajout de beaucoup de commentaires
/************************************************************************************************/

/*                                          DEFINE                                              */
/************************************************************************************************/
#ifndef MOD_PILE
#define MOD_PILE
/************************************************************************************************/

/*                                         INCLUDES                                             */
/************************************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
//#include <string.h>
//#include <memory.h>
/************************************************************************************************/

/*                                        DECLARATION                                           */
/************************************************************************************************/

void pile_initialiser(int* pile[], int* nb_elements);
/*
Cette fonction sert a initialiser une pile et sont nb_elements à NULL.
Parametre : int* pile[]         --> Pointeur sur tableau (qui est notre pile)
            int* nb_elements    --> Pointeur sur le nombre d'éléments de la pile
Return : Void			
*/
/************************************************************************************************/

void pile_ajouter(int* pile[], int* nb_elements, int entier);
/*
Cette fonction sert a ajouter un element à une pile.
Parametre : int* pile[]         --> Pointeur sur tableau (qui est notre pile)
            int* nb_elements    --> Pointeur sur le nombre d'éléments de la pile
            int entier          --> L'entier à ajouter sur le dessus de la pile
Return : Void			
*/
/************************************************************************************************/

void pile_copier(int* pile_destination[], int nb_elements_destination, int *pile_source[], int nb_elements_source);
/*
Cette fonction sert a copier une pile dans un autre. 
Si la pile de source est plus grande que la pile de destination, on décale les valeurs en "enlevant" la variable tableau[0].
Si la pile de source est plus petite que la pile de destination, on laisse un espace vide en tableau[0].
si la pile de source est identique à la pile de destination, on cpie sans décalage.
Parametre : int* pile_destination           --> Pointeur sur notre pile de destination
            int nb_elements_destination     --> Nombre d'éléments de la pile de destination
            int* pile_source                --> Pointeur sur la pile source
            int nb_element_source           --> Nombre d'éléments de la pile de source
Return : Void			
*/
/************************************************************************************************/

void pile_afficher(int *pile[], int nb_elements);
/*
Cette fonction sert a afficher tous les éléments d'une pile.
Parametre : int* pile[]         --> Pointeur sur tableau (qui est notre pile)
            int nb_elements     --> Nombre d'éléments de la pile
Return : Void			
*/
/************************************************************************************************/

int pile_enlever(int* pile[], int* nb_elements);
/*
Cette fonction sert a enlever le dernier élément d'une pile.
Parametre : int* pile[]         --> Pointeur sur tableau (qui est notre pile)
            int* nb_elements    --> Pointeur sur le nombre d'éléments de la pile
Return : l'entier qui à été enlever			
*/
/************************************************************************************************/

void pile_detruire(int* pile[], int* nb_elements);
/*
Cette fonction sert a detruire une pile et de remetre son pointeur et  le nombre d'éléments à 0.
Parametre : int* pile[]         --> Pointeur sur tableau (qui est notre pile)
            int* nb_elements    --> Pointeur sur le nombre d'éléments de la pile
Return : Void			
*/
/************************************************************************************************/

int main()
{
    int* pile[] = {NULL};
    int nb_elements = 0;

    //int* p_temp[] = {NULL};
    printf("Debut du program\n");

    pile_initialiser(pile, &nb_elements);
    printf("Initialisation de la pile\n");
    system("pause");

    /* Partie de calcul pour tester la syntaxe

        *p_temp = (int *)calloc(nb_elements+1, sizeof(int*));
        assert(*pile != NULL);
        printf("Initialisation de la pile temporaire\n");
        //system("pause");

        printf("\nCalcul\n");
        (*pile)[0] = 12;
        (*p_temp)[0] = (*pile)[0];
        printf("Affichage p_temp[0] : %d\n",(*p_temp)[0] );
        system("pause");
    */
    //Teste des fonctions
    printf("ajouter\n");
    pile_ajouter(pile, &nb_elements, 69);
    pile_ajouter(pile, &nb_elements, 70);
    pile_ajouter(pile, &nb_elements, 78);
    pile_ajouter(pile, &nb_elements, 10);
    pile_afficher(pile, nb_elements);
    system("pause");

    printf("Enlever\n");
    pile_enlever(pile, &nb_elements);
    pile_enlever(pile, &nb_elements);
    pile_afficher(pile, nb_elements);

    pile_detruire(pile, &nb_elements);

    //free(*p_temp);
    return 0;
}
/*                                        DEFINITION                                            */
/************************************************************************************************/
void pile_initialiser(int* pile[], int* nb_elements)
{
    *nb_elements = 0;

    *pile = (int *)calloc(*nb_elements+1, sizeof(int*));
    assert (*pile!=NULL);
}
void pile_detruire(int* pile[], int* nb_elements)
{
    *nb_elements = 0;
    free(*pile);
    *pile = NULL;
}

void pile_ajouter(int* pile[], int* nb_elements, int entier)
{
    //Initialisation des variables temporaire
    int nb_ele_temp = (*nb_elements) + 1; //On veut un tableau une case plus grande
    int* p_temp[] = {NULL};

    //Allocation de la memoire temporaire
    *p_temp = (int *)calloc(nb_ele_temp, sizeof(int*));
    assert ((*p_temp)!=NULL);           //Verification si le pointeur est en erreur

    pile_copier(p_temp, nb_ele_temp, pile, *nb_elements);
    (*p_temp)[0] = entier;

    free(*pile);               //Libération de la première pile
    *pile = *p_temp;           //assignation de la nouvelle pile
    (*nb_elements)++ ;
}

int pile_enlever(int *pile[], int* nb_elements)
{
    //Initialisation des variables temporaire
    int nb_ele_temp = (*nb_elements) - 1; //On veut un tableau une case de moins
    int* p_temp[] = {NULL};
    int entier;

    //Allocation de la memoire temporaire
    *p_temp = (int *)calloc(nb_ele_temp, sizeof(int*));
    assert ((*p_temp)!=NULL);                           //Verification si le pointeur est en erreur
    entier = (*pile)[0];                                //La valeur qui sera perdu est celle-ci
    pile_copier(p_temp, nb_ele_temp, pile, *nb_elements);


    free(*pile);                     //Libération de la première pile
    *pile = *p_temp;                 //assignation de la nouvelle pile
    (*nb_elements)-- ;

    return entier;
}

void pile_afficher(int *pile[], int nb_elements)
{
    //Affiche tous les éléments de la pile
    int i;

    for(i = 0 ; i < nb_elements; i++)
    {
        printf("Deplacement #%d : %d\n", i, (*pile)[i]);
    }
}

void pile_copier(int* pile_destination[], int nb_elements_destination, int *pile_source[], int nb_elements_source)
{
    //si la pile de source est plus grande que la pile de destination
    if(nb_elements_destination < nb_elements_source )
    {
        int i = 0;

        for(i = 0; i < nb_elements_destination; i++)
        {
            ((*pile_destination)[i]) = (*pile_source)[i+1]; // Copie la source dans une case de moins
        }
    }
    //si la pile de destination est plus grande que la pile de source
    if(nb_elements_destination > nb_elements_source )
    {
        int i = 0;

        for(i = 0; i < nb_elements_source; i++)
        {
            ((*pile_destination)[i+1]) = (*pile_source)[i]; // Copie la source dans une case plus loin pour la destination
        }
    }
    //si la pile de destination est égal que la pile de source
    if(nb_elements_destination == nb_elements_source )
    {
        int i = 0;

        for(i = 0; i < nb_elements_source; i++)
        {
            ((*pile_destination)[i]) = (*pile_source)[i]; // Copie la source dans la destination sans décalage
        }
    }

}

#endif // MOD_PILE
