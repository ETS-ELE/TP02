/************************************************************************************************/
//Projet   : Projet TP_2_Labyrinthe
//Fichier  : Module_Pile.c
//Contenu  : Contient les fonction relatif à la création, modification et destruction de pile
//Objectif : Création d'un algorithme de réalisation de labyrinthe
//Création : 20 Octobre 2014
//                                                  Creer par Samuel - Link - Geoffroy-Heroux
//                                                            Francis Masse
//                                                            Christopher Dom
//                                                            Vincent
/************************************************************************************************/

/*                                       MODIFICATION                                           */
/************************************************************************************************/
//Modification : 23 Octobre 2014 --> Link
//      -- Ajout de assert() pour tester l'allocation de memoire
//      -- Recréation de pile_copier(). Permet la copie de nos pile qu'elles soit plus grande ou plus petite l'une de l'autre
//      -- Modification de pile_ajouter() et pile_enlever().
//      -- Ajout de ifndef
/************************************************************************************************/

#ifndef MOD_PILE
#define MOD_PILE

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
//#include <string.h>
//#include <memory.h>


void pile_initialiser(int* pile[], int* nb_elements);
void pile_ajouter(int* pile[], int* nb_elements, int entier);
void pile_copier(int* pile_destination[], int nb_elements_destination, int *pile_source[], int nb_elements_source);
void pile_afficher(int *pile[], int nb_elements);
int pile_enlever(int* pile[], int* nb_elements);
void pile_detruire(int* pile[], int* nb_elements);

int main()
{
    int* pile[] = {NULL};
    int nb_elements = 0;

    //int* p_temp[] = {NULL};
    printf("Debut du program\n");

    pile_initialiser(pile, &nb_elements);
    printf("Initialisation de la pile\n");
    system("pause");

    /* Partie de calcul pour tester la syntaxe

        *p_temp = (int *)calloc(nb_elements+1, sizeof(int*));
        assert(*pile != NULL);
        printf("Initialisation de la pile temporaire\n");
        //system("pause");

        printf("\nCalcul\n");
        (*pile)[0] = 12;
        (*p_temp)[0] = (*pile)[0];
        printf("Affichage p_temp[0] : %d\n",(*p_temp)[0] );
        system("pause");
    */
    //Teste des fonctions
    printf("ajouter\n");
    pile_ajouter(pile, &nb_elements, 69);
    pile_ajouter(pile, &nb_elements, 70);
    pile_ajouter(pile, &nb_elements, 78);
    pile_ajouter(pile, &nb_elements, 10);
    pile_afficher(pile, nb_elements);
    system("pause");

    printf("Enlever\n");
    pile_enlever(pile, &nb_elements);
    pile_enlever(pile, &nb_elements);
    pile_afficher(pile, nb_elements);

    pile_detruire(pile, &nb_elements);

    //free(*p_temp);
    return 0;
}

void pile_initialiser(int* pile[], int* nb_elements)
{
    *nb_elements = 0;

    *pile = (int *)calloc(*nb_elements+1, sizeof(int*));
    assert (*pile!=NULL);
}
void pile_detruire(int* pile[], int* nb_elements)
{
    *nb_elements = 0;
    free(*pile);
    *pile = NULL;
}

void pile_ajouter(int* pile[], int* nb_elements, int entier)
{
    //Initialisation des variables temporaire
    int nb_ele_temp = (*nb_elements) + 1; //On veut un tableau une case plus grande
    int* p_temp[] = {NULL};

    //Allocation de la memoire temporaire
    *p_temp = (int *)calloc(nb_ele_temp, sizeof(int*));
    assert ((*p_temp)!=NULL);           //Verification si le pointeur est en erreur

    pile_copier(p_temp, nb_ele_temp, pile, *nb_elements);
    (*p_temp)[0] = entier;

    free(*pile);               //Libération de la première pile
    *pile = *p_temp;           //assignation de la nouvelle pile
    (*nb_elements)++ ;
}

int pile_enlever(int *pile[], int* nb_elements)
{
    //Initialisation des variables temporaire
    int nb_ele_temp = (*nb_elements) - 1; //On veut un tableau une case de moins
    int* p_temp[] = {NULL};
    int entier;

    //Allocation de la memoire temporaire
    *p_temp = (int *)calloc(nb_ele_temp, sizeof(int*));
    assert ((*p_temp)!=NULL);                           //Verification si le pointeur est en erreur
    entier = (*pile)[0];                                //La valeur qui sera perdu est celle-ci
    pile_copier(p_temp, nb_ele_temp, pile, *nb_elements);


    free(*pile);                     //Libération de la première pile
    *pile = *p_temp;                 //assignation de la nouvelle pile
    (*nb_elements)-- ;

    return entier;
}

void pile_afficher(int *pile[], int nb_elements)
{
    //Affiche tous les éléments de la pile
    int i;

    for(i = 0 ; i < nb_elements; i++)
    {
        printf("Deplacement #%d : %d\n", i, (*pile)[i]);
    }
}

void pile_copier(int* pile_destination[], int nb_elements_destination, int *pile_source[], int nb_elements_source)
{
    //si la pile de source est plus grande que la pile de destination
    if(nb_elements_destination < nb_elements_source )
    {
        int i = 0;

        for(i = 0; i < nb_elements_destination; i++)
        {
            ((*pile_destination)[i]) = (*pile_source)[i+1]; // Copie la source dans une case de moins
        }
    }
    //si la pile de destination est plus grande que la pile de source
    if(nb_elements_destination > nb_elements_source )
    {
        int i = 0;

        for(i = 0; i < nb_elements_source; i++)
        {
            ((*pile_destination)[i+1]) = (*pile_source)[i]; // Copie la source dans une case plus loin pour la destination
        }
    }

}

#endif // MOD_PILE
