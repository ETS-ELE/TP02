/************************************************************************************************/
//Projet   : Projet TP_2_Labyrinthe
//Fichier  : Module_Pile.c
//Contenu  : Contient les fonction relatif à la création, modification et destruction de pile
//Objectif : Création d'un algorithme de réalisation de labyrinthe
//Création : 20 Octobre 2014
//                                                 Creer par: Samuel - Link - Geoffroy-Heroux
//                                                            Francis Masse
//                                                            Christopher Dom
//                                                            Vincent Lynch
/************************************************************************************************/

/*                                       MODIFICATION                                           */
/************************************************************************************************/
//Modification : 23 Octobre 2014 --> Link
//      -- Ajout de assert() pour tester l'allocation de memoire
//      -- Recréation de pile_copier(). Permet la copie de nos pile qu'elles soit plus grande ou plus petite l'une de l'autre
//      -- Modification de pile_ajouter() et pile_enlever().
//      -- Ajout de ifndef
//      -- Ajout de beaucoup de commentaires
/************************************************************************************************/

/*                                          DEFINE                                              */
/************************************************************************************************/
#ifndef MOD_PILE
#define MOD_PILE
/************************************************************************************************/

/*                                         INCLUDES                                             */
/************************************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <memory.h>
/************************************************************************************************/

/*                                        DECLARATION                                           */
/************************************************************************************************/

void pile_initialiser(int* pile[], int* nb_elements);
/*
Cette fonction sert a initialiser une pile et sont nb_elements à NULL.
Parametre : int* pile[]         --> Pointeur sur tableau (qui est notre pile)
            int* nb_elements    --> Pointeur sur le nombre d'éléments de la pile
Return : Void			
*/
/************************************************************************************************/

void pile_ajouter(int* pile[], int* nb_elements, int entier);
/*
Cette fonction sert a ajouter un element à une pile.
Parametre : int* pile[]         --> Pointeur sur tableau (qui est notre pile)
            int* nb_elements    --> Pointeur sur le nombre d'éléments de la pile
            int entier          --> L'entier à ajouter sur le dessus de la pile
Return : Void			
*/
/************************************************************************************************/

void pile_copier(int* pile_destination[], int nb_elements_destination, int *pile_source[], int nb_elements_source);
/*
Cette fonction sert a copier une pile dans un autre. 
Si la pile de source est plus grande que la pile de destination, on décale les valeurs en "enlevant" la variable tableau[0].
Si la pile de source est plus petite que la pile de destination, on laisse un espace vide en tableau[0].
si la pile de source est identique à la pile de destination, on cpie sans décalage.
Parametre : int* pile_destination           --> Pointeur sur notre pile de destination
            int nb_elements_destination     --> Nombre d'éléments de la pile de destination
            int* pile_source                --> Pointeur sur la pile source
            int nb_element_source           --> Nombre d'éléments de la pile de source
Return : Void			
*/
/************************************************************************************************/

void pile_afficher(int *pile[], int nb_elements);
/*
Cette fonction sert a afficher tous les éléments d'une pile.
Parametre : int* pile[]         --> Pointeur sur tableau (qui est notre pile)
            int nb_elements     --> Nombre d'éléments de la pile
Return : Void			
*/
/************************************************************************************************/

int pile_enlever(int* pile[], int* nb_elements);
/*
Cette fonction sert a enlever le dernier élément d'une pile.
Parametre : int* pile[]         --> Pointeur sur tableau (qui est notre pile)
            int* nb_elements    --> Pointeur sur le nombre d'éléments de la pile
Return : l'entier qui à été enlever			
*/
/************************************************************************************************/

void pile_detruire(int* pile[], int* nb_elements);
/*
Cette fonction sert a detruire une pile et de remetre son pointeur et  le nombre d'éléments à 0.
Parametre : int* pile[]         --> Pointeur sur tableau (qui est notre pile)
            int* nb_elements    --> Pointeur sur le nombre d'éléments de la pile
Return : Void			
*/
/************************************************************************************************/

void pile_concatener(int* pile_destination[], int* nb_elements_destination, int pile_source[], int nb_elements_source);
/*

Parametre : 
Return : 			
*/
/************************************************************************************************/

void pile_concatener(int* pile_destination[], int* nb_elements_destination, int pile_source[], int nb_elements_source);
/*

Parametre : 
Return : 			
*/
/************************************************************************************************/
int pile_est_present(int pile[], int nb_elements, int entier);
/*

Parametre : 
Return : 			
*/
/************************************************************************************************/
void pile_tronquer(int* pile[], int* nb_elements, int indice);
/*

Parametre : 
Return : 			
*/
/************************************************************************************************/

int main()
{
	int tableau[5] = {10,20,30,40,50}, tableau2[5] = {60,70,80,90,100};
	int *ptr_tableau = tableau, *ptr_tableau2 = tableau2;
	int nb_element = 5, *ptr_element = &nb_element, test=0;

	// Test de concatener (FONCTIONNE sauf pour free())
	printf("test de concatener:\n%d\n", ptr_tableau[4]);
	printf("%d\n", *ptr_element);
	pile_concatener(&ptr_tableau, ptr_element , tableau2,5);
	printf("%d\n", *ptr_element);
	printf("%d\n", ptr_tableau[9]);

	//test de pile_est_present
	test = pile_est_present(tableau, nb_element, 20);
	printf("test de pile_est_present:\n%d\n", test);
	test = pile_est_present(tableau, nb_element, 19);
	printf("%d\n", test);

	//test de tronquer
	printf("test pour tronquer:\n%d\n", tableau[9]);
	pile_tronquer(&ptr_tableau, ptr_element, 4);
	printf("%d\n", tableau[4]);
	printf("%d\n", tableau[5]);

    return 0;
}

/*                                        DEFINITION                                            */
/************************************************************************************************/

void pile_tronquer(int* pile[], int* nb_elements, int indice)
{
	int * nouvelle_pile[] = {NULL};
	int x = 0;
	int y = 0;

	*nouvelle_pile = (int*) calloc((indice+1), sizeof(int));

	for (x=0; x<= indice ; x++)
	{
		(*nouvelle_pile)[x] = (*pile)[x];
	}

	//free()
	*pile = *nouvelle_pile;
}
int pile_est_present(int pile[], int nb_elements, int entier)
{

	int x = 0;

	for (x = 0; x < nb_elements ; x++)
	{
		if (pile[x] == entier)  {return x;}
	}

	return -1;
}
void pile_concatener(int* pile_destination[], int* nb_elements_destination, int pile_source[], int nb_elements_source)
{
	int * nouvelle_pile[] = {NULL};
	int x = 0;
	int y = 0;

	*nouvelle_pile = (int*) calloc((*nb_elements_destination + nb_elements_source), sizeof(int));

	for (x=0; x < nb_elements_source ; x++)
	{
	(*nouvelle_pile)[x] = pile_source[x];
	}
	
	for ( y = x; y < (x+(*nb_elements_destination)) ; y++)
	{
	(*nouvelle_pile)[y] = (*pile_destination)[y-x];
	}

	*nb_elements_destination = *nb_elements_destination + nb_elements_source;
	//free(*pile_destination);
	*pile_destination = *nouvelle_pile;
}
void pile_initialiser(int* pile[], int* nb_elements)
{
    *nb_elements = 0;

    *pile = (int *)calloc(*nb_elements+1, sizeof(int*));
    assert (*pile!=NULL);
}
void pile_detruire(int* pile[], int* nb_elements)
{
    *nb_elements = 0;
    free(*pile);
    *pile = NULL;
}
void pile_ajouter(int* pile[], int* nb_elements, int entier)
{
    //Initialisation des variables temporaire
    int nb_ele_temp = (*nb_elements) + 1; //On veut un tableau une case plus grande
    int* p_temp[] = {NULL};

    //Allocation de la memoire temporaire
    *p_temp = (int *)calloc(nb_ele_temp, sizeof(int*));
    assert ((*p_temp)!=NULL);           //Verification si le pointeur est en erreur

    pile_copier(p_temp, nb_ele_temp, pile, *nb_elements);
    (*p_temp)[0] = entier;

    free(*pile);               //Libération de la première pile
    *pile = *p_temp;           //assignation de la nouvelle pile
    (*nb_elements)++ ;
}
int pile_enlever(int *pile[], int* nb_elements)
{
    //Initialisation des variables temporaire
    int nb_ele_temp = (*nb_elements) - 1; //On veut un tableau une case de moins
    int* p_temp[] = {NULL};
    int entier;

    //Allocation de la memoire temporaire
    *p_temp = (int *)calloc(nb_ele_temp, sizeof(int*));
    assert ((*p_temp)!=NULL);                           //Verification si le pointeur est en erreur
    entier = (*pile)[0];                                //La valeur qui sera perdu est celle-ci
    pile_copier(p_temp, nb_ele_temp, pile, *nb_elements);


    free(*pile);                     //Libération de la première pile
    *pile = *p_temp;                 //assignation de la nouvelle pile
    (*nb_elements)-- ;

    return entier;
}
void pile_afficher(int *pile[], int nb_elements)
{
    //Affiche tous les éléments de la pile
    int i;

    for(i = 0 ; i < nb_elements; i++)
    {
        printf("Deplacement #%d : %d\n", i, (*pile)[i]);
    }
}
void pile_copier(int* pile_destination[], int nb_elements_destination, int *pile_source[], int nb_elements_source)
{
    //si la pile de source est plus grande que la pile de destination
    if(nb_elements_destination < nb_elements_source )
    {
        int i = 0;

        for(i = 0; i < nb_elements_destination; i++)
        {
            ((*pile_destination)[i]) = (*pile_source)[i+1]; // Copie la source dans une case de moins
        }
    }
    //si la pile de destination est plus grande que la pile de source
    if(nb_elements_destination > nb_elements_source )
    {
        int i = 0;

        for(i = 0; i < nb_elements_source; i++)
        {
            ((*pile_destination)[i+1]) = (*pile_source)[i]; // Copie la source dans une case plus loin pour la destination
        }
    }
    //si la pile de destination est égal que la pile de source
    if(nb_elements_destination == nb_elements_source )
    {
        int i = 0;

        for(i = 0; i < nb_elements_source; i++)
        {
            ((*pile_destination)[i]) = (*pile_source)[i]; // Copie la source dans la destination sans décalage
        }
    }

}

#endif // MOD_PILE
